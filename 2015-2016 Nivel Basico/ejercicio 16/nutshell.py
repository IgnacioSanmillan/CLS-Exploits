from keystone import *
import array, struct, binascii

p = lambda x : struct.pack ("<L", x)
u = lambda x : struct.unpack ("<I", x)

def littleE2Hex (x):
	val = binascii.unhexlify (x.encode ("hex") )
	y = array.array ('h', val)
	y.byteswap ()
	return u (val)[0]


class Nutshell:
	def __init__(self, arch, bin):
		if arch.find("86"):
			self.arch = KS_ARCH_X86
			self.mode = KS_MODE_32
			self.bin = bin
		else:
			self.arch = 0
			self.mode = 0
			self.bin = bin

	def nut_asm(self, ops):
		try:
			ks = Ks(self.arch, self.mode)
			encoding , count = ks.asm(ops)
			return "".join("%s" % chr(i) for i in encoding)
		except KsError as e:
			return "Error: %s" % e
			

	def nut_resolve(self, reg, func, ver):
	#resolver returns function to call into eax
		lens = len(func)
		func += "\x00"*(32 - len(func))
		
		if ver == 1:
                    func = func[:4][::-1].encode("hex")
		    resolver = """                      and    esp,0xfffffffc;
							xor    edx,edx;
							mov    esi,DWORD PTR fs:[edx+0x30];
							mov    esi,DWORD PTR [esi+0xc];
							mov    esi,DWORD PTR [esi+0xc];
							lods   eax,DWORD PTR ds:[esi];
							mov    esi,DWORD PTR [eax];
							mov    edi,DWORD PTR [esi+0x18];
							mov    ebx,DWORD PTR [edi+0x3c];
							mov    ebx,DWORD PTR [edi+ebx*1+0x78];
							mov    esi,DWORD PTR [edi+ebx*1+0x20];
							add    esi,edi;
							mov    ecx,DWORD PTR [edi+ebx*1+0x24];
							add    ecx,edi;

							iter:;
							inc    edx;
							lods   eax,DWORD PTR ds:[esi];
							cmp    DWORD PTR [edi+eax*1], 0x%s ;
							jne    iter;
							movzx  edx,WORD PTR [ecx+edx*2-0x2];
							mov    esi,DWORD PTR [edi+ebx*1+0x1c];
							add    esi,edi;
							add    edi,DWORD PTR [esi+edx*4];
							mov    %s, edi;
							nop;""" % (func, reg)
		else:
			func = {1 : func[:4][::-1].encode("hex"),    2 : func[4:8][::-1].encode("hex"),
			        3 : func[8:12][::-1].encode("hex"),  4 : func[12:16][::-1].encode("hex"),
			        5 : func[16:20][::-1].encode("hex"), 6 : func[20:24][::-1].encode("hex"),
				7 : func[24:28][::-1].encode("hex"), 8 : func[28:32][::-1].encode("hex") }

			resolver =	"""
							push ebp;
							mov ebp, esp;

							xor eax, eax;
							push eax
							
							push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s
							push 0x%s
							mov [ebp-4], esp;
							
							xor ebx, ebx;	
							mov ebx, fs:[0x30];		  
							mov ebx, [ebx + 0x0C];	  
							mov ebx, [ebx + 0x14];	
							mov ebx, [ebx];			 
							mov ebx, [ebx];			 
							mov ebx, [ebx + 0x10];	  
							mov [ebp+16], ebx;	 

							add ebx, [ebx + 0x3c];	  	 
							mov ebx, [ebx + 0x78];	  
							add ebx, [ebp + 16];

							xor esi, esi;			  
							mov edx, [ebx + 0x20];	  
							add edx, [ebp+16];

					iter:;
							push esi;					
							mov ecx, %d;							
							mov esi, [edx + esi * 4];	
							add esi, [ebp+16];		
							mov edi, [ebp-4];						
							repe cmpsb;					
							je iter_end;					
								
							pop esi;						
							inc esi;						
							cmp esi, [ebx+0x14];			
							jl iter;						
							jmp exit;					

					iter_end:;
							pop esi;						
							mov ecx, [ebx + 0x1c];		
							add ecx, [ebp+16];	

							mov edx, [ebx + 0x24];		
							add edx, [ebp+16];		
							movzx ebx, word ptr[edx + esi * 2];

							mov ebx, [ecx + ebx * 4];	
							add ebx, [ebp+16];		
											
						exit:;
							pop edi;
							pop edi;
							pop edi;					
							mov %s, ebx;	
						""" % (func[8],func[7],func[6],func[5], func[4], func[3],func[2],func[1], lens, reg)
			
		return self.nut_asm(resolver)

        def nut_revolve (self, reg1, reg2):
                str1 = "GetModuleHandle"
                len1 = len(str1)
                str1 += "\x00" * (32 - len1)

                str2 = "GetProcAddress"
                len2 = len(str2)
                str2 += "\x00" * (32 - len2)
                
                str1 = {1 : str1[:4][::-1].encode("hex"),    2 : str1[4:8][::-1].encode("hex"),
			3 : str1[8:12][::-1].encode("hex"),  4 : str1[12:16][::-1].encode("hex"),
			5 : str1[16:20][::-1].encode("hex"), 6 : str1[20:24][::-1].encode("hex"),
			7 : str1[24:28][::-1].encode("hex"), 8 : str1[28:32][::-1].encode("hex") }

                str2 = {1 : str2[:4][::-1].encode("hex"),    2 : str2[4:8][::-1].encode("hex"),
			3 : str2[8:12][::-1].encode("hex"),  4 : str2[12:16][::-1].encode("hex"),
			5 : str2[16:20][::-1].encode("hex"), 6 : str2[20:24][::-1].encode("hex"),
			7 : str2[24:28][::-1].encode("hex"), 8 : str2[28:32][::-1].encode("hex") }

	        resolver =	"""
							push ebp;
							mov ebp, esp;

							xor eax, eax;
							push eax
							
							push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s;
							mov [ebp-4], esp;
							

                                                        push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s;
							mov [ebp+40], esp;
							
                                        new:            xor ebx, ebx;	
							mov ebx, fs:[0x30];		  
							mov ebx, [ebx + 0x0C];	  
							mov ebx, [ebx + 0x14];	
							mov ebx, [ebx];			 
							mov ebx, [ebx];			 
							mov ebx, [ebx + 0x10];	  
							mov [ebp+16], ebx;	 

							add ebx, [ebx + 0x3c];	  	 
							mov ebx, [ebx + 0x78];	  
							add ebx, [ebp + 16];

				    			xor esi, esi;			  
							mov edx, [ebx + 0x20];	  
							add edx, [ebp+16];

					iter:;
							push esi;					
							mov ecx, %d;							
							mov esi, [edx + esi * 4];	
							add esi, [ebp+16];
                                                        cmp eax, 1
                                                        je fix
							mov edi, [ebp-4];
                                                        jmp comp
                                        fix:
                                                        mov edi, [ebp+40]
                                        comp:

							repe cmpsb;					
							je iter_end;					
								
							pop esi;						
							inc esi;						
							cmp esi, [ebx+0x14];			
							jl iter;						
							jmp exit;					

					iter_end:;
							pop esi;						
							mov ecx, [ebx + 0x1c];		
							add ecx, [ebp+16];	

							mov edx, [ebx + 0x24];		
							add edx, [ebp+16];		
							movzx ebx, word ptr[edx + esi * 2];

							mov ebx, [ecx + ebx * 4];	
							add ebx, [ebp+16];
                                                        inc eax
                                                        cmp eax, 2
                                                        jne first
                                                        je exit
                                        first:
                                                        mov [ebp-4], ebx
							jmp new				
					exit:;
							pop edi;
							pop edi;
							pop edi;					
							mov %s, ebx;
                                                        mov %s, [ebp-4]
						""" % (str1[5],str1[4],str1[3],str1[2],str1[1],str2[5],str2[4],str2[3],str2[2],str2[1], len1, reg1, reg2)
                return self.nut_asm(resolver)


