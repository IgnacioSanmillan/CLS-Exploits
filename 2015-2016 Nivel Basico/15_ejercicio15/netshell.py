from keystone import *
import array, struct, binascii

p = lambda x : struct.pack ("<L", x)
u = lambda x : struct.unpack ("<I", x)

def littleE2Hex (x):
	val = binascii.unhexlify (x.encode ("hex") )
	y = array.array ('h', val)
	y.byteswap ()
	return u (val)[0]


class Nutshell:
	def __init__(self, arch, bin):
		if arch.find("86"):
			self.arch = KS_ARCH_X86
			self.mode = KS_MODE_32
			self.bin = bin
		else:
			self.arch = 0
			self.mode = 0
			self.bin = bin

	def nut_asm(self, ops):
		try:
			ks = Ks(self.arch, self.mode)
			encoding , count = ks.asm(ops)
			return "".join("%s" % chr(i) for i in encoding)
		except KsError as e:
			return "Error: %s" % e
			

	def nut_resolve(self, reg, func, ver):
	#resolver returns function to call into eax
		lens = len(func)
		func += "\x00"*(32 - len(func))
		
		if ver == 1:
			func = "0x" + func.encode("hex")[6:]
			resolver = """  and    sp,0xfffc;
							xor    edx,edx;
							mov    esi,DWORD PTR fs:[edx+0x30];
							mov    esi,DWORD PTR [esi+0xc];
							mov    esi,DWORD PTR [esi+0xc];
							lods   eax,DWORD PTR ds:[esi];
							mov    esi,DWORD PTR [eax];
							mov    edi,DWORD PTR [esi+0x18];
							mov    ebx,DWORD PTR [edi+0x3c];
							mov    ebx,DWORD PTR [edi+ebx*1+0x78];
							mov    esi,DWORD PTR [edi+ebx*1+0x20];
							add    esi,edi;
							mov    ecx,DWORD PTR [edi+ebx*1+0x24];
							add    ecx,edi;

							iter:;
							inc    edx;
							lods   eax,DWORD PTR ds:[esi];
							cmp    DWORD PTR [edi+eax*1], %s ;
							jne    iter;
							movzx  edx,WORD PTR [ecx+edx*2-0x2];
							mov    esi,DWORD PTR [edi+ebx*1+0x1c];
							add    esi,edi;
							add    edi,DWORD PTR [esi+edx*4];
							mov    %s, edi;
							nop;""" % (func, reg)
		else:
			func = {1 : func[:4][::-1].encode("hex"),    2 : func[4:8][::-1].encode("hex"),
					3 : func[8:12][::-1].encode("hex"),  4 : func[12:16][::-1].encode("hex"),
					5 : func[16:20][::-1].encode("hex"), 6 : func[20:24][::-1].encode("hex"),
					7 : func[24:28][::-1].encode("hex"), 8 : func[28:32][::-1].encode("hex") }

			resolver =	"""
							push ebp;
							mov ebp, esp;

							xor eax, eax;
							push eax
							
							push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s;
							push 0x%s
							push 0x%s
							mov [ebp-4], esp;
							
							xor ebx, ebx;	
							mov ebx, fs:[0x30];		  
							mov ebx, [ebx + 0x0C];	  
							mov ebx, [ebx + 0x14];	
							mov ebx, [ebx];			 
							mov ebx, [ebx];			 
							mov ebx, [ebx + 0x10];	  
							mov [ebp+16], ebx;	 

							add ebx, [ebx + 0x3c];	  	 
							mov ebx, [ebx + 0x78];	  
							add ebx, [ebp + 16];

							xor esi, esi;			  
							mov edx, [ebx + 0x20];	  
							add edx, [ebp+16];

					iter:;
							push esi;					
							mov ecx, %d;							
							mov esi, [edx + esi * 4];	
							add esi, [ebp+16];		
							mov edi, [ebp-4];						
							repe cmpsb;					
							je iter_end;					
								
							pop esi;						
							inc esi;						
							cmp esi, [ebx+0x14];			
							jl iter;						
							jmp exit;					

					iter_end:;
							pop esi;						
							mov ecx, [ebx + 0x1c];		
							add ecx, [ebp+16];	

							mov edx, [ebx + 0x24];		
							add edx, [ebp+16];		
							movzx ebx, word ptr[edx + esi * 2];

							mov ebx, [ecx + ebx * 4];	
							add ebx, [ebp+16];		
											
						exit:;
							pop edi;
							pop edi;
							pop edi;					
							mov %s, ebx;	
						""" % (func[8],func[7],func[6],func[5], func[4], func[3],func[2],func[1], lens, reg)
			
		return self.nut_asm(resolver)

